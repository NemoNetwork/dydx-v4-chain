// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nemo_network/clob/order_removals.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type OrderRemoval_RemovalReason int32

const (
	// REMOVAL_REASON_UNSPECIFIED represents an unspecified removal reason. This
	// removal reason is used as a catchall and should never appear on an
	// OrderRemoval in the operations queue.
	OrderRemoval_REMOVAL_REASON_UNSPECIFIED OrderRemoval_RemovalReason = 0
	// REMOVAL_REASON_UNDERCOLLATERALIZED represents a removal of an order which
	// if filled in isolation with respect to the current state of the
	// subaccount would leave the subaccount undercollateralized.
	OrderRemoval_REMOVAL_REASON_UNDERCOLLATERALIZED OrderRemoval_RemovalReason = 1
	// REMOVAL_REASON_INVALID_REDUCE_ONLY represents a removal of a reduce-only
	// order which if filled in isolation with respect to the current state of
	// the subaccount would cause the subaccount's existing position to increase
	// or change sides.
	OrderRemoval_REMOVAL_REASON_INVALID_REDUCE_ONLY OrderRemoval_RemovalReason = 2
	// REMOVAL_REASON_POST_ONLY_WOULD_CROSS_MAKER_ORDER represents a removal of
	// a stateful post-only order that was deemed invalid because it crossed
	// maker orders on the book of the proposer.
	OrderRemoval_REMOVAL_REASON_POST_ONLY_WOULD_CROSS_MAKER_ORDER OrderRemoval_RemovalReason = 3
	// REMOVAL_REASON_INVALID_SELF_TRADE represents a removal of a stateful
	// order that was deemed invalid because it constituted a self trade on the
	// proposers orderbook.
	OrderRemoval_REMOVAL_REASON_INVALID_SELF_TRADE OrderRemoval_RemovalReason = 4
	// REMOVAL_REASON_CONDITIONAL_FOK_COULD_NOT_BE_FULLY_FILLED represents a
	// removal of a conditional FOK order that was deemed invalid because it
	// could not be completely filled. Conditional FOK orders should always be
	// fully-filled or removed in the block after they are triggered.
	OrderRemoval_REMOVAL_REASON_CONDITIONAL_FOK_COULD_NOT_BE_FULLY_FILLED OrderRemoval_RemovalReason = 5
	// REMOVAL_REASON_CONDITIONAL_IOC_WOULD_REST_ON_BOOK represents a removal
	// of a conditional IOC order.
	// Conditional IOC orders should always have their remaining size removed
	// in the block after they are triggered.
	OrderRemoval_REMOVAL_REASON_CONDITIONAL_IOC_WOULD_REST_ON_BOOK OrderRemoval_RemovalReason = 6
	// REMOVAL_REASON_FULLY_FILLED represents a removal of an order that
	// was fully filled and should therefore be removed from state.
	OrderRemoval_REMOVAL_REASON_FULLY_FILLED OrderRemoval_RemovalReason = 7
	// REMOVAL_REASON_FULLY_FILLED represents a removal of an order that
	//  would lead to the subaccount violating isolated subaccount constraints.
	OrderRemoval_REMOVAL_REASON_VIOLATES_ISOLATED_SUBACCOUNT_CONSTRAINTS OrderRemoval_RemovalReason = 8
)

var OrderRemoval_RemovalReason_name = map[int32]string{
	0: "REMOVAL_REASON_UNSPECIFIED",
	1: "REMOVAL_REASON_UNDERCOLLATERALIZED",
	2: "REMOVAL_REASON_INVALID_REDUCE_ONLY",
	3: "REMOVAL_REASON_POST_ONLY_WOULD_CROSS_MAKER_ORDER",
	4: "REMOVAL_REASON_INVALID_SELF_TRADE",
	5: "REMOVAL_REASON_CONDITIONAL_FOK_COULD_NOT_BE_FULLY_FILLED",
	6: "REMOVAL_REASON_CONDITIONAL_IOC_WOULD_REST_ON_BOOK",
	7: "REMOVAL_REASON_FULLY_FILLED",
	8: "REMOVAL_REASON_VIOLATES_ISOLATED_SUBACCOUNT_CONSTRAINTS",
}

var OrderRemoval_RemovalReason_value = map[string]int32{
	"REMOVAL_REASON_UNSPECIFIED":                               0,
	"REMOVAL_REASON_UNDERCOLLATERALIZED":                       1,
	"REMOVAL_REASON_INVALID_REDUCE_ONLY":                       2,
	"REMOVAL_REASON_POST_ONLY_WOULD_CROSS_MAKER_ORDER":         3,
	"REMOVAL_REASON_INVALID_SELF_TRADE":                        4,
	"REMOVAL_REASON_CONDITIONAL_FOK_COULD_NOT_BE_FULLY_FILLED": 5,
	"REMOVAL_REASON_CONDITIONAL_IOC_WOULD_REST_ON_BOOK":        6,
	"REMOVAL_REASON_FULLY_FILLED":                              7,
	"REMOVAL_REASON_VIOLATES_ISOLATED_SUBACCOUNT_CONSTRAINTS":  8,
}

func (x OrderRemoval_RemovalReason) String() string {
	return proto.EnumName(OrderRemoval_RemovalReason_name, int32(x))
}

func (OrderRemoval_RemovalReason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b8b04774b76a4d0, []int{0, 0}
}

// OrderRemoval is a request type used for forced removal of stateful orders.
type OrderRemoval struct {
	OrderId       OrderId                    `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"order_id"`
	RemovalReason OrderRemoval_RemovalReason `protobuf:"varint,2,opt,name=removal_reason,json=removalReason,proto3,enum=nemo_network.clob.OrderRemoval_RemovalReason" json:"removal_reason,omitempty"`
}

func (m *OrderRemoval) Reset()         { *m = OrderRemoval{} }
func (m *OrderRemoval) String() string { return proto.CompactTextString(m) }
func (*OrderRemoval) ProtoMessage()    {}
func (*OrderRemoval) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b8b04774b76a4d0, []int{0}
}
func (m *OrderRemoval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderRemoval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderRemoval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderRemoval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderRemoval.Merge(m, src)
}
func (m *OrderRemoval) XXX_Size() int {
	return m.Size()
}
func (m *OrderRemoval) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderRemoval.DiscardUnknown(m)
}

var xxx_messageInfo_OrderRemoval proto.InternalMessageInfo

func (m *OrderRemoval) GetOrderId() OrderId {
	if m != nil {
		return m.OrderId
	}
	return OrderId{}
}

func (m *OrderRemoval) GetRemovalReason() OrderRemoval_RemovalReason {
	if m != nil {
		return m.RemovalReason
	}
	return OrderRemoval_REMOVAL_REASON_UNSPECIFIED
}

func init() {
	proto.RegisterEnum("nemo_network.clob.OrderRemoval_RemovalReason", OrderRemoval_RemovalReason_name, OrderRemoval_RemovalReason_value)
	proto.RegisterType((*OrderRemoval)(nil), "nemo_network.clob.OrderRemoval")
}

func init() {
	proto.RegisterFile("nemo_network/clob/order_removals.proto", fileDescriptor_3b8b04774b76a4d0)
}

var fileDescriptor_3b8b04774b76a4d0 = []byte{
	// 488 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x92, 0xcd, 0x6e, 0xd3, 0x4e,
	0x14, 0xc5, 0xe3, 0x36, 0xff, 0xb6, 0x9a, 0x3f, 0xad, 0xcc, 0x88, 0x45, 0x15, 0x84, 0x5b, 0x22,
	0x51, 0x75, 0x13, 0x1b, 0x4a, 0xf9, 0x90, 0xca, 0x66, 0xe2, 0x19, 0x4b, 0xa3, 0x4c, 0x3d, 0xd1,
	0x8c, 0x1d, 0xd4, 0x6e, 0xae, 0xf2, 0x61, 0xa5, 0x11, 0x49, 0xa6, 0x72, 0x42, 0x81, 0xb7, 0xe0,
	0x4d, 0x78, 0x8d, 0x2e, 0x2b, 0xb1, 0x61, 0x85, 0x50, 0xf2, 0x22, 0xc8, 0x76, 0x90, 0xda, 0x94,
	0xb0, 0xf2, 0xbd, 0xbe, 0xbf, 0x7b, 0xce, 0xd5, 0xe8, 0xa0, 0x83, 0x71, 0x32, 0x32, 0x30, 0x4e,
	0xa6, 0x9f, 0x4c, 0xfa, 0xc1, 0xeb, 0x0e, 0x4d, 0xc7, 0x33, 0x69, 0x2f, 0x49, 0x21, 0x4d, 0x46,
	0xe6, 0xaa, 0x3d, 0x9c, 0xb8, 0x97, 0xa9, 0x99, 0x1a, 0xfc, 0xf0, 0x36, 0xe7, 0x66, 0x5c, 0xe5,
	0x51, 0xdf, 0xf4, 0x4d, 0x3e, 0xf5, 0xb2, 0xaa, 0x00, 0x2b, 0x4f, 0x56, 0x08, 0x16, 0xe3, 0xea,
	0xf7, 0x32, 0x7a, 0x20, 0xb3, 0x5e, 0x15, 0xfa, 0xf8, 0x04, 0x6d, 0x15, 0x86, 0x83, 0xde, 0xae,
	0xb5, 0x6f, 0x1d, 0xfe, 0x7f, 0x54, 0x71, 0xef, 0x79, 0xb9, 0xf9, 0x0a, 0xef, 0xd5, 0xcb, 0xd7,
	0x3f, 0xf7, 0x4a, 0x6a, 0xd3, 0x14, 0x2d, 0x8e, 0xd0, 0xce, 0xe2, 0x4e, 0x48, 0x93, 0xf6, 0xc4,
	0x8c, 0x77, 0xd7, 0xf6, 0xad, 0xc3, 0x9d, 0xa3, 0xda, 0x2a, 0x89, 0x85, 0xab, 0xbb, 0xf8, 0xaa,
	0x7c, 0x49, 0x6d, 0xa7, 0xb7, 0xdb, 0xea, 0xb7, 0x75, 0xb4, 0x7d, 0x07, 0xc0, 0x0e, 0xaa, 0x28,
	0x76, 0x2a, 0x5b, 0x44, 0x80, 0x62, 0x44, 0xcb, 0x10, 0xe2, 0x50, 0x37, 0x99, 0xcf, 0x03, 0xce,
	0xa8, 0x5d, 0xc2, 0x07, 0xa8, 0x7a, 0x6f, 0x4e, 0x99, 0xf2, 0xa5, 0x10, 0x24, 0x62, 0x8a, 0x08,
	0x7e, 0xce, 0xa8, 0x6d, 0xfd, 0x85, 0xe3, 0x61, 0x8b, 0x08, 0x4e, 0x41, 0x31, 0x1a, 0xfb, 0x0c,
	0x64, 0x28, 0xce, 0xec, 0x35, 0x7c, 0x8c, 0x9e, 0x2f, 0x71, 0x4d, 0xa9, 0xa3, 0x7c, 0x0a, 0xef,
	0x65, 0x2c, 0x28, 0xf8, 0x4a, 0x6a, 0x0d, 0xa7, 0xa4, 0xc1, 0x14, 0x48, 0x45, 0x99, 0xb2, 0xd7,
	0xf1, 0x33, 0xf4, 0x74, 0x85, 0xba, 0x66, 0x22, 0x80, 0x48, 0x11, 0xca, 0xec, 0x32, 0x7e, 0x87,
	0xde, 0x2e, 0x61, 0xbe, 0x0c, 0x29, 0x8f, 0xb8, 0x0c, 0x89, 0x80, 0x40, 0x36, 0xc0, 0xcf, 0x2d,
	0x42, 0x19, 0x41, 0x9d, 0x41, 0x10, 0x0b, 0x71, 0x06, 0x01, 0x17, 0x82, 0x51, 0xfb, 0x3f, 0xfc,
	0x0a, 0xbd, 0xf8, 0xc7, 0x36, 0x97, 0xfe, 0xe2, 0x40, 0xc5, 0xf2, 0x83, 0xa1, 0x2e, 0x65, 0xc3,
	0xde, 0xc0, 0x7b, 0xe8, 0xf1, 0xd2, 0xda, 0x1d, 0xdd, 0x4d, 0x7c, 0x82, 0xde, 0x2c, 0x01, 0x2d,
	0x2e, 0xb3, 0xd7, 0xd3, 0xc0, 0x75, 0x5e, 0x50, 0xd0, 0x71, 0x9d, 0xf8, 0xbe, 0x8c, 0xc3, 0x28,
	0x33, 0xd5, 0x91, 0x22, 0x3c, 0x8c, 0xb4, 0xbd, 0x55, 0x6f, 0x5e, 0xcf, 0x1c, 0xeb, 0x66, 0xe6,
	0x58, 0xbf, 0x66, 0x8e, 0xf5, 0x75, 0xee, 0x94, 0x6e, 0xe6, 0x4e, 0xe9, 0xc7, 0xdc, 0x29, 0x9d,
	0xbf, 0xee, 0x0f, 0xa6, 0x17, 0x1f, 0x3b, 0x6e, 0xd7, 0x8c, 0xbc, 0x2c, 0x13, 0xb5, 0x3f, 0xc9,
	0xbc, 0x3a, 0xae, 0x75, 0x2f, 0xda, 0x83, 0xb1, 0x97, 0xe7, 0xb2, 0x6b, 0x86, 0xde, 0xe7, 0x22,
	0xad, 0xd3, 0x2f, 0x97, 0xc9, 0xa4, 0xb3, 0x91, 0xff, 0x7e, 0xf9, 0x3b, 0x00, 0x00, 0xff, 0xff,
	0x4a, 0xed, 0xf3, 0xc7, 0x20, 0x03, 0x00, 0x00,
}

func (m *OrderRemoval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderRemoval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderRemoval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RemovalReason != 0 {
		i = encodeVarintOrderRemovals(dAtA, i, uint64(m.RemovalReason))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.OrderId.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOrderRemovals(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintOrderRemovals(dAtA []byte, offset int, v uint64) int {
	offset -= sovOrderRemovals(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *OrderRemoval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OrderId.Size()
	n += 1 + l + sovOrderRemovals(uint64(l))
	if m.RemovalReason != 0 {
		n += 1 + sovOrderRemovals(uint64(m.RemovalReason))
	}
	return n
}

func sovOrderRemovals(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOrderRemovals(x uint64) (n int) {
	return sovOrderRemovals(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *OrderRemoval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrderRemovals
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderRemoval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderRemoval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrderRemovals
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrderRemovals
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrderRemovals
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OrderId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemovalReason", wireType)
			}
			m.RemovalReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrderRemovals
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemovalReason |= OrderRemoval_RemovalReason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOrderRemovals(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOrderRemovals
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOrderRemovals(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOrderRemovals
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOrderRemovals
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOrderRemovals
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOrderRemovals
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOrderRemovals
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOrderRemovals
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOrderRemovals        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOrderRemovals          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOrderRemovals = fmt.Errorf("proto: unexpected end of group")
)
